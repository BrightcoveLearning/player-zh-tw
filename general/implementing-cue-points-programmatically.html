---
title:以編程方式實現提示點
parent: General Information
description: In this topic, you will gain an understanding of cue points with Brightcove Player. You will then see how to programmatically create cue points and handle when a cue point is dispatched.
---

<article class="bcls-article">
  <h1>以編程方式實現提示點</h1>
  <summary>{{ page.description }}</summary>
  <style type="text/css">
.video-js { width: 640px; height: 360px; }
</style>
  <section class="bcls-section">
    <h2 id="Overview">概述</h2>
    <p>可以為視頻設置提示點。在視頻播放期間，當擊中每個提示點時將調度一個事件。</p>
    <div class="video-cloud-only">
      <p>播放以下視頻，以查看播放器在前滾，中滾（5秒，10秒，12秒）和後滾時間顯示提示點信息。</p>
      <video-js id="myPlayerID" data-video-id="4740963811001" data-account="1752604059001" data-player="VkIrj2aFx" data-embed="default" class="video-js" controls="">&nbsp;</video-js>
      <p>********提示點信息********</p>
      <p id="insertionPoint">&nbsp;</p>
      <p>******結束提示點信息******</p>
      <aside class="bcls-aside bcls-aside--information">注意：這<strong>ID</strong>變量沒有關聯的值，因為它們沒有在 Video Cloud 中分配。
    </div>
    <div class="player-only">
      <p>播放此視頻，您將看到播放器下方顯示的四個提示點信息。</p>
      <video-js id="myPlayerID3" data-account="3676484087001" data-player="4f14e962-a11f-441f-8c00-0c89b8edb0a6" data-embed="default" class="video-js" controls="">&nbsp;</video-js>
      <p id="insertionPoint3">&nbsp;</p>
    </div>
  </section>
  <section class="bcls-section">
    <h2 id="Key_concepts">關鍵概念</h2>
    <p><span class="video-cloud-only">必須理解一些概念才能有效地使用Brightcove Player中的提示點。這些概念在文檔的此部分中說明。</span><span class="player-only">必須理解以下概念才能有效地使用Brightcove Player中的提示點。</span></p>
    <div class="video-cloud-only">
      <h3>Video Cloud目錄提示點</h3>
      <p>要理解的第一個概念與術語有關。在Brightcove Player中，根據HTML標準，提示點存儲為文本跟踪元素。這意味著，當使用視頻雲視頻時，任何“視頻雲樣式"提示點都將轉換為文本軌道。</p>
      <p>這些“視頻雲樣式"提示點也可以稱為“目錄"提示點，因為它們是從“視頻雲"目錄中讀取的（請參閱<a href="/references/player-catalog.html">玩家目錄</a>文檔以獲取有關目錄的更多信息）。進行此轉換時，目錄提示點中的某些信息（如類型和提示點時間）將轉換為文本軌道。</p>
      <h3>目錄提示點結構</h3>
      <p>下一個要理解的概念是目錄提示點和HTML標准在結構上有很大的不同。區別在於HTML提示點可以具有持續時間。這意味著對於每個提示點，將調度兩個提示點更改事件：一個在提示點的開始，一個在提示點的結束。</p>
      <p>在轉換過程中，每個目錄提示點都將轉換為具有相同開始和停止時間的提示點。這意味著，對於每個目錄提示點，將調度兩個提示點事件，並且必須在代碼中進行說明。</p>
    </div>
    <h3><code translate="No">activecues</code> array</h3>
    <p><span class="video-cloud-only">其他</span><span class="player-only">一個</span>在處理HTML提示點時要理解的重要概念點是<code translate="No">activeCues</code>大批。所有提示點都在數組中定義。還有另一個數組，<code translate="No">activeCues</code>，其中包含“活動"的提示點，這意味著播放時間介於提示點的開始時間和停止時間之間。</p>
    <p>使用目錄提示點時，開始時間和停止時間相同，因此它們僅在定義的第二個時間有效。同樣，對於目錄提示點，由於兩個提示點不會重疊，因此極不可能同時激活兩個提示點。</p>
    <aside class="bcls-aside bcls-aside--information">注意：可以有多組文本軌道，例如一組用於提示點，另一組用於視頻字幕。在本文檔的示例代碼中，提示點文本軌道位於TextTracks數組的第一個和第二個元素中。您將在代碼中看到這一點。
    <h3>提示點類型</h3>
    <p>在本文檔中，您將看到提示點帶有<code translate="No">type</code>屬性分配了一個值。在Studio用戶界面中創建提示點時，將分配這些類型值。有兩種類型的提示點，但是它們都只是向字符串提供一個字符串值<code translate="No">type</code>財產。僅當在處理提示點信息時在自定義JavaScript中使用了適當的值時，該值才有用。類型在這裡詳細說明：</p>
    <ul>
      <li><strong>廣告</strong> -分配的字符串值<code translate="No">AD</code>到<code translate="No">type</code>財產</li>
      <li><strong>代碼</strong> -分配的字符串值<code translate="No">CODE</code>到<code translate="No">type</code>財產</li>
    </ul>
  </section>
  <section class="bcls-section video-cloud-only">
    <h2 id="Video_Cloud_cue_points">視頻雲提示點</h2>
    <p>在本文檔的此部分中，您將學習設置目錄提示點並偵聽目錄提示點事件調度。</p>
    <h3>設置視頻雲提示點</h3>
    <p>可以使用Video Cloud Studio以及其他多種方式將Video Cloud提示點與視頻相關聯，詳細信息請參見本文檔：<a href="https://studio.support.brightcove.com/media/working-cue-points-media-module.html">在媒體模塊中使用提示點</a>。</p>
    <h3>對視頻雲提示點採取行動-視頻靜態綁定到播放器</h3>
    <p>在本部分中，您將學習將視頻靜態綁定到播放器時處理目錄提示點的情況，這意味著該視頻已在Studio中或直接使用Player Management API加載到了播放器中。</p>
    <p>為了防止在提示點加載之前嘗試處理提示點的競爭狀況，您需要使用<code translate="No">loadedmetadata</code>在處理提示點之前要分派的事件。閱讀完正確的文本軌道後，請使用<code translate="No">oncuechange</code>偵聽提示點事件以調度事件。</p>
    <p>以下代碼顯示偵聽提示點並顯示提示點中的數據。請注意，在此示例中，視頻是靜態綁定到播放器的。</p>
    <ul>
      <li>第24行：創建一個段落元素作為在其中註入動態創建的HTML的位置。</li>
      <li>第31,43行：使用<code translate="No">one()</code>為該事件添加事件偵聽器的方法<code translate="No">loadedmetadata</code>事件僅一次。事件處理函數在此處匿名定義。</li>
      <li>第32行：使用以下命令檢索TextTracks數組<code translate="No">textTracks()</code>方法，然後將包含提示點的第零個元素分配給變量<code translate="No">tt</code>。注意，在某些實現中，提示點可能位於不同的數組元素中。見<a href="#findtrack">找到正確的軌道</a>以下部分以獲取更多信息。</li>
      <li>第33,41行：設置事件處理程序函數的時間<code translate="No">oncuechange</code>事件已調度。</li>
      <li>第34行：檢查以確保獲得第一個（第零個數組元素）提示點分派。如果沒有這種情況，您將看到每個提示點都會被作用兩次。請注意，如果您使用的提示點的持續時間重疊，則此條件必須有所不同。</li>
      <li>第35-39行：使用來自提示點的信息動態創建HTML，並將其註入HTML頁面。</li>
      <li>第 42 行：播放視頻。</li>
    </ul>
    <pre class="line-numbers" data-start="17">
<code class="language-html" translate="No">&lt;video-js id="myPlayerID"
data-account="1507807800001"
data-player="6aac508a-741e-41a2-bc7a-5805644cf089"
data-embed="default"
data-video-id="1507781667001"
class="video-js" controls&gt;&lt;/video-js&gt;

&lt;p id="insertionPoint"&gt;&lt;/p&gt;
&lt;script src="https://players.brightcove.net/1507807800001/6aac508a-741e-41a2-bc7a-5805644cf089_default/index.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
  videojs.getPlayer('myPlayerID').ready(function() {
    var player = this;
    player.one("loadedmetadata", function () {
      var tt = player.textTracks()[0];
      tt.oncuechange = function () {
        if (tt.activeCues[0] !== undefined) {
          var dynamicHTML = "id: " + tt.activeCues[0].id + ", ";
          dynamicHTML += "text: " + tt.activeCues[0].text + ", ";
          dynamicHTML += "startTime: " + tt.activeCues[0].startTime + ",  ";
          dynamicHTML += "endTime: " + tt.activeCues[0].endTime;
          document.getElementById("insertionPoint").innerHTML += dynamicHTML + "&lt;br/&gt;";
        }
      }
      player.play();
    });
  });
&lt;/script&gt;</code></pre>
    <h3>對視頻雲提示點採取行動-在播放器中動態加載視頻</h3>
    <p>在本節中，您將學習使用以下工具將視頻動態加載到播放器中時處理目錄提示點的方法。<code translate="No">catalog.getVideo()</code>和<code translate="No">catalog.load()</code>方法。</p>
    <p>使用播放器目錄獲取和加載視頻時，處理提示點要比使用靜態綁定的視頻時要容易一些，因為您無需使用<code translate="No">loadedmetadata</code>事件。</p>
    <ul>
      <li>第76行：創建一個段落元素作為在其中註入動態創建的HTML的位置。</li>
      <li>第83,97行：使用<code translate="No">catalog.getVideo()</code>檢索視頻的方法。回調函數在此處匿名定義。</li>
      <li>第85行：使用<code translate="No">catalog.load()</code>將視頻加載到播放器的方法。</li>
      <li>第86行：使用以下命令檢索TextTracks數組<code translate="No">textTracks()</code>方法，然後將包含提示點的第零個元素分配給變量<code translate="No">tt</code>。注意，在某些實現中，提示點可能位於不同的數組元素中。見<a href="#findtrack">找到正確的軌道</a>以下部分以獲取更多信息。</li>
      <li>第87,95行：設置事件處理程序函數的時間<code translate="No">oncuechange</code>事件已調度。</li>
      <li>第88行：檢查以確保定義了第一個（第零個數組元素）提示點。如果沒有這種條件，您將看到每個提示點都會被執行兩次，第二次在提示中沒有定義元素<code translate="No">activecues</code>數組（因為第二個提示更改是針對提示點結束的）。請注意，如果您使用的提示點的持續時間重疊，則此條件必須有所不同。</li>
      <li>89-93行：使用來自提示點的信息動態創建HTML，並將其註入HTML頁面。</li>
      <li>第96行：播放視頻。</li>
    </ul>
    <pre class="line-numbers" data-start="69">
<code class="language-html" translate="No">&lt;video-js id="myPlayerID"
  data-account="1507807800001"
  data-player="3c59134e-89e8-4864-87e2-3cc871f8c361"
  data-embed="default"
  data-video-id=""
  class="video-js" controls&gt;&lt;/video-js&gt;

  &lt;p id="insertionPoint"&gt;&lt;/p&gt;

  &lt;script src="https://players.brightcove.net/1507807800001/3c59134e-89e8-4864-87e2-3cc871f8c361_default/index.min.js"&gt;&lt;/script&gt;

  &lt;script&gt;
  videojs.getPlayer('myPlayerID').ready(function() {
    var player = this;
    player.catalog.getVideo('1507781667001', function (error, video) {
      //deal with error
      player.catalog.load(video);
      player.one("loadedmetadata", function () {
        var tt = player.textTracks()[0];
        tt.oncuechange = function () {
          if (tt.activeCues[0] !== undefined) {
            var dynamicHTML = "id: " + tt.activeCues[0].id + ", ";
            dynamicHTML += "text: " + tt.activeCues[0].text + ", ";
            dynamicHTML += "startTime: " + tt.activeCues[0].startTime + ",  ";
            dynamicHTML += "endTime: " + tt.activeCues[0].endTime;
            document.getElementById("insertionPoint").innerHTML += dynamicHTML + "&lt;br/&gt;";
          }
        }
      });
      player.play();
    });
  });
&lt;/script&gt;</code></pre>
    <h3 id="allvcinfo">檢索所有Video Cloud提示點信息</h3>
    <p>您可能已經註意到，並非所有Video Cloud提示點信息都可以直接從<code translate="No">activecues</code>大批。通過從<code translate="No">mediainfo</code>財產。</p>
    <p>此解決方案的基本方法是：</p>
    <ol>
      <li>等待<code translate="No">loadstart</code>的活動<code translate="No">mediainfo</code>要填充的屬性。</li>
      <li>分配<code translate="No">cue_points</code>來自的數組<code translate="No">mediainfo</code>變量的屬性。此變量包含完整的Video Cloud提示點信息。</li>
      <li>在提示點事件中，根據<code translate="No">time</code>適當的價值。這將使用一個輔助函數來完成，該函數根據對像中的屬性值從數組中獲取對象。</li>
      <li>從提示點使用數據。</li>
    </ol>
    <p>下圖顯示了整個提示點數組（左上），單個提示點數據集合（右上）以及該單個提示點數據集合的一個屬性（右下）。</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="cue point data" src="/assets/images/general/cue-point-all-vc-data.png" /></figure>
    <p>在下面的代碼段中，將僅說明上述示例中的新代碼/更改過的代碼。</p>
    <ul>
      <li>452-463行：包括將用於從所有提示點的數組中提取單個提示點數據集合的函數。請注意，將所有提示點的數組，要在其中搜索特定值的屬性以及最後要搜索的值傳遞給它。</li>
      <li>432行：聽著<code translate="No">loadstart</code>事件。當您的視頻開始加載時，<code translate="No">mediainfo</code>屬性已填充。</li>
      <li>434行：將所有Video Cloud提示點的數組分配給一個變量。</li>
      <li>443行：在提示點調度事件處理程序中，將特定提示點的數據集合分配給變量。這就是第一個項目符號中提到的函數的調用位置。使用的參數是：
        <ul>
          <li><code translate="No">cuePointAra</code>：Video Cloud提示點的整個集合。</li>
          <li><code translate="No">'time'</code>：在其中搜索值的屬性。</li>
          <li><code translate="No">tt.activeCues[0].startTime</code>：提示點分派事件處理程序中當前正在處理的提示點的開始時間。</li>
        </ul>
      </li>
      <li>444-445行：調試<code translate="No">console.log()</code>方法調用，應在生產代碼中將其刪除。</li>
    </ul>
    <pre class="line-numbers" data-start="426">
<code class="language-html" translate="No">&lt;script&gt;
  videojs.getPlayer('myPlayerID').ready(function() {
    var myPlayer = this,
      cuePointAra = [],
      allCuePointData;
    myPlayer.on('loadstart', function () {
      //console.log('mediainfo', myPlayer.mediainfo);
      cuePointAra = myPlayer.mediainfo.cue_points;
      var tt = myPlayer.textTracks()[0];
      tt.oncuechange = function () {
        if (tt.activeCues[0] !== undefined) {
          var dynamicHTML = "id: " + tt.activeCues[0].id + ", ";
          dynamicHTML += "text: " + tt.activeCues[0].text + ", ";
          dynamicHTML += "startTime: " + tt.activeCues[0].startTime + ",  ";
          dynamicHTML += "endTime: " + tt.activeCues[0].endTime;
          document.getElementById("insertionPoint").innerHTML += dynamicHTML + "&lt;br/&gt;";
          allCuePointData = getSubArray(cuePointAra, 'time', tt.activeCues[0].startTime);
          console.log('cue point data:', allCuePointData);
          console.log('cue point metadata:', allCuePointData[0].metadata);
        }
      }
      myPlayer.play();
      myPlayer.muted(true);
    });

    function getSubArray(targetArray, objProperty, value) {
      var i, totalItems = targetArray.length,
        objFound = false,
        idxArr = [];
      for (i = 0; i &lt; totalItems; i++) {
        if (targetArray[i][objProperty] === value) {
          objFound = true;
          idxArr.push(targetArray[i]);
        }
      }
      return idxArr;
    };
  });
&lt;/script&gt;</code></pre>
  </section>
  <section class="bcls-section">
    <h2 id="HTML5_standard_cue_points">HTML5標準提示點</h2>
    <p>HTML5標準提示點以指定格式存儲為跟踪元素。可以在以下HTML5 Rocks教程中找到良好的入門內容：<a href="//www.html5rocks.com/en/tutorials/track/basics/">Track元素入門</a>。在本節中，您將學習WebVTT提示點文件的格式，然後學習如何處理這些提示點。</p>
    <h3>WebVTT提示點的文件格式</h3>
    <p>WebVTT文件格式是嚴格定義的。對於提示點，文件的組成如下：</p>
    <ul>
      <li>字符串<strong>WebVTT</strong>作為文件的第一行</li>
      <li>單個空白行</li>
      <li>特定提示點的標識符</li>
      <li>表格中的持續時間<strong>00：00：00.000-&gt; 00：00：00.000</strong> ;這是hours：minutes：seconds.milliseconds格式，並經過嚴格分析；如有必要，數字必須用零填充</li>
      <li>持續時間之後的字符到下一個空白行將放置在<strong>文本</strong>價值;如果您希望在此處存儲多個不同的值，JSON可以很好地工作，因為它很容易解析</li>
      <li>單個空白行</li>
      <li>可以使用標識符/持續時間/文本/空白行格式添加多個提示點</li>
    </ul>
    <aside class="bcls-aside bcls-aside--tip">注意：您可以使用此驗證您的 WebVTT 格式<a href="//quuz.org/webvtt/">驗證器</a> .
    <p>以下是有效的WebVTT提示點文檔，該文檔定義了兩個提示點，一個提示點的持續時間為2-5秒，另一個提示點的持續時間為10-15秒：</p>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">WEBVTT

multiCell
00:00:02.000 --&gt; 00:00:05.000
{
"title": "Multi-celled organisms",
"description": "Multi-celled organisms have different types of cells that perform specialized functions.",
"src": "multiCell.jpg",
"href": "http://en.wikipedia.org/wiki/Multicellular"
}

insects
00:00:10.000 --&gt; 00:00:15.000
{
"title": "Insects",
"description": "Insects are the most diverse group of animals on the planet with estimates for the total number of current species range from two million to 50 million. The first insects appeared around 400 million years ago, identifiable by a hard exoskeleton, three-part body, six legs, compound eyes and antennae.",
"src": "insects.jpg",
"href": "http://en.wikipedia.org/wiki/Insects"
}</code></pre>
    <p>當您播放以下視頻時，您將看到上面顯示的提示點WebVTT文件。在提示點的開頭，您會看到動態創建的HTML注入頁面，然後是來自<strong>文本</strong>場地。在提示點的末尾，消息<strong>提示點持續時間超過</strong>被陳列。</p>
    <video-js id="myPlayerID2" data-video-id="4607357817001" data-account="1752604059001" data-player="VkIrj2aFx" data-embed="default" class="video-js" controls="">
      <track kind="metadata" src="https://solutions.brightcove.com/bcls/tests/player/cuepoints.vtt" />
    </video-js>
    <p>********提示點信息********</p>
    <p id="insertionPoint2">&nbsp;</p>
    <p>******結束提示點信息******</p>
    <h3>流程提示點概述</h3>
    <p>使用HTML5標準提示點的基本步驟是：</p>
    <ol>
      <li>使用以下命令讀取包含提示點的WebVTT文件<code translate="No">&lt;track&gt;</code>標籤嵌套為<code translate="No">&lt;video-js&gt;</code>標籤。</li>
      <li>在一個<code translate="No">loadedmetadata</code>事件處理程序，檢索適當的文本跟踪元素。</li>
      <li>在同一事件處理程序中，為<code translate="No">oncuechange</code>提示點事件。</li>
      <li>在裡面<code translate="No">oncuechange</code>事件處理程序，請檢查<code translate="No">activecues</code>數組對象定義了第零個元素，如果是，則從提示點開始執行操作。<aside class="bcls-aside bcls-aside--information">注意：你將會擁有<code translate="No">oncuechange</code>提示點開始和停止時調度的事件。這<code translate="No">activecues</code>數組僅在提示點持續時間內具有一個值。因此，如果一個<code translate="No">oncuechange</code>事件發生並且在該事件中沒有定義的對象<code translate="No">activecues</code>數組，您知道調度的事件是針對提示點停止的。
      </li>
      <li>在裡面<code translate="No">oncuechange</code>事件處理程序，請檢查<code translate="No">activecues</code>數組對象定義了第零個元素，如果沒有，則在提示點停止位置上動作。</li>
    </ol>
    <aside class="bcls-aside bcls-aside--information">注意：如果您的提示點具有重疊的持續時間，則需要稍微更改上述步驟中的邏輯。
    <div class="video-cloud-only">
      <h3>處理提示點代碼</h3>
      <p>&nbsp;</p>
      <ul>
        <li>第122行：通過使用以下命令讀取WebVTT文件來創建文本軌道<code translate="No">&lt;track&gt;</code>標籤。</li>
        <li>第126行：創建一個段落元素作為在其中註入動態創建的HTML的位置。</li>
        <li>第134,152行：使用<code translate="No">one()</code>只聽一次的方法<code translate="No">loadedmetadata</code>事件。事件處理函數在此處匿名定義。</li>
        <li>第135行：將最後加載的文本軌道的索引分配給變量。</li>
        <li>第136行：使用以下命令檢索textTracks數組<code translate="No">textTracks()</code>方法，使用上一步中確定的索引將數組的最後一個元素分配給變量。見<a href="#findtrack">找到正確的軌道</a>以下部分介紹了此邏輯的各種變化。</li>
        <li>第137,149行：設置事件處理程序函數的時間<code translate="No">oncuechange</code>事件已調度。</li>
        <li>第138行：檢查以確保在activeCues數組中定義了第一個（第零個數組元素）提示點。這告訴您這是一個開始提示點事件。</li>
        <li>139-145行：使用來自提示點的信息動態創建HTML，並將其註入HTML頁面。這包括解析JSON並顯示該JSON的各個字段。</li>
        <li>第146-147行：顯示一條提示，指出到達提示點的終點。</li>
        <li>第150行：播放視頻。</li>
      </ul>
      <pre class="line-numbers" data-start="115">
<code class="language-html" translate="No">&lt;video-js id="myPlayerID2"
  data-account="1752604059001"
  data-player="8cfb6785-c4be-43b4-af68-7ca2fe3a6ebf"
  data-embed="default"
  data-video-id="3851380732001"
  class="video-js" controls&gt;

  &lt;track kind="metadata" src="https://solutions.brightcove.com/bcls/tests/player/cuepoints.vtt" /&gt;
&lt;/video-js&gt;

&lt;p id="insertionPoint2"&gt;&lt;/p&gt;

&lt;script src="https://players.brightcove.net/1752604059001/8cfb6785-c4be-43b4-af68-7ca2fe3a6ebf_default/index.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
  videojs.getPlayer('myPlayerID').ready(function() {
    var myPlayer = this;
    myPlayer.one("loadedmetadata", function () {
      var trackIndex = myPlayer.textTracks().length - 1;
      var tt = myPlayer.textTracks()[trackIndex];
      tt.oncuechange = function () {
        if (tt.activeCues[0] !== undefined) {
          var dynamicHTML = "id: " + tt.activeCues[0].id + ", ";
          dynamicHTML += "text: " + tt.activeCues[0].text + ", ";
          dynamicHTML += "startTime: " + tt.activeCues[0].startTime + ",  ";
          dynamicHTML += "endTime: " + tt.activeCues[0].endTime;
          document.getElementById("insertionPoint2").innerHTML += dynamicHTML + "&lt;br/&gt;&lt;br/&gt;";
          jsonData = JSON.parse(tt.activeCues[0].text);
          document.getElementById("insertionPoint2").innerHTML += jsonData.title + ": " + jsonData.description + "&lt;br/&gt;&lt;br/&gt;";
        } else {
          document.getElementById("insertionPoint2").innerHTML += "Cue point duration over" + "&lt;br/&gt;&lt;br/&gt;";
        }
      } //end oncuechange
      myPlayer.play();
      myPlayer.muted(true);
    }); //end loadedmetadata
  }); //end ready
&lt;/script&gt;</code></pre>
    </div>
    <div class="player-only">
      <h3>處理提示點代碼</h3>
      <p>&nbsp;</p>
      <ul>
        <li>第270行：通過使用以下命令讀取WebVTT文件來創建文本軌道<code translate="No">&lt;track&gt;</code>標籤。</li>
        <li>第273行：創建一個段落元素作為在其中註入動態創建的HTML的位置。</li>
        <li>285,309行：使用<code translate="No">one()</code>只聽一次的方法<code translate="No">loadedmetadata</code>事件。事件處理函數在此處匿名定義。</li>
        <li>286行：將最後加載的文本軌道的索引分配給變量。</li>
        <li>287行：使用以下命令檢索textTracks數組<code translate="No">textTracks()</code>方法，使用上一步中確定的索引將數組的最後一個元素分配給變量。見<a href="#findtrack">找到正確的軌道</a>以下部分介紹了此邏輯的各種變化。</li>
        <li>289,301行：設置事件處理程序函數的時間<code translate="No">oncuechange</code>事件已調度。</li>
        <li>290行：檢查以確保在activeCues數組中定義了第一個（第零個數組元素）提示點。這告訴您這是一個開始提示點事件。</li>
        <li>第291-294行：使用來自提示點的信息動態創建HTML，並將其註入HTML頁面。這包括解析JSON並顯示該JSON的各個字段。</li>
        <li>第295-297行：顯示一條提示，指出到達提示點的終點。</li>
        <li>第302行：播放視頻。</li>
      </ul>
      <p>&nbsp;</p>
    </div>
    <p>可以假設您可以使用<code translate="No">addRemoteTextTrack()</code>方法。在這種情況下，這將是不可靠的，因為您可能會遇到競爭狀況，提示點在嘗試使用提示點之前無法準備好進行處理。使用以下命令添加WebVTT文件是安全的<code translate="No">&lt;track&gt;</code>標籤，如圖所示。</p>
  </section>
  <section class="bcls-section">
    <h2 id="findtrack">找到正確的軌道</h2>
    <p>如果多個文本軌道與播放器相關聯，則在本文檔中的許多地方都可能出現問題。假定播放器僅與一個文本軌道相關聯，因此使用了以下代碼：<code translate="No">var tt = myPlayer.textTracks()[0];</code>。選擇第零個數組元素將假定與播放器關聯的單個文本軌道。</p>
    <p>文本軌道不僅用於提示點，而且還用於其他類型的數據。這<strong>種類</strong>屬性可以包含以下值：</p>
    <ul>
      <li>字幕</li>
      <li>字幕</li>
      <li>說明</li>
      <li>章節</li>
      <li>元數據</li>
    </ul>
    <p>這意味著很有可能將多個文本軌道與播放器相關聯，並且需要一種方法來為您的應用程序邏輯找到正確的文本軌道。以下代碼循環遍歷可用的文本軌道，直到<strong>元數據</strong>找到（提示點）值：</p>
    <pre class="line-numbers">
<code class="language-html" translate="No">&lt;script type="text/javascript"&gt;
  videojs.getPlayer('myPlayerID').ready(function() {
    var myPlayer = this,
      allTextTacks,
      attLength,
      tt;
    myPlayer.one("loadedmetadata", function () {
      allTextTacks = myPlayer.textTracks();
      attLength = allTextTacks.length;
      for (var i = 0; i &lt; attLength; i++) {
        if (allTextTacks[i].kind === 'metadata') {
          tt = allTextTacks[i];
          break;
        };
      };
    });
  });
&lt;/script&gt;</code></pre>
    <p>然後，可以使用前面示例中的邏輯來使用<code translate="No">tt</code>變量，其中包含所需的文本軌道。</p>
  </section>
  <section class="bcls-section video-cloud-only">
    <h2 id="Programmatic_cue_points">程序化提示點</h2>
    <p>可以以編程方式添加提示點。關鍵方法來自HTML5 <code translate="No">VTTCue</code>界面。您可以使用以下語法創建提示點：</p>
    <pre>
<code class="language-javascript" translate="No">new VTTCue( startTime, endTime, text )</code></pre>
    <p>處理提示點的邏輯與前面的示例非常相似，因此將僅詳細說明與上面使用的代碼不同的代碼。</p>
    <ul>
      <li>
        <p>第43,44行：添加一個<code translate="No">textTrack</code>使用玩家的<code translate="No">addRemoteTextTrack()</code>方法。指定<code translate="No">kind</code>成為<strong>元數據</strong>和<code translate="No">label</code>， 在這種情況下<strong>定時提示點</strong>。</p>
        <aside class="bcls-aside bcls-aside--information">注意：因為只能從播放器中刪除遠程文本軌道，所以我們建議使用<a href="https://docs.brightcove.com/brightcove-player/current-release/Player.html#addRemoteTextTrack">addRemoteTextTrack()</a>方法。
      </li>
      <li>
        <p>45-48行：等待10毫秒，然後使用播放器的提示創建兩個提示點<code translate="No">addCue()</code>方法。提示點使用HTML5的實例化<code translate="No">VTTCue()</code>構造函數。</p>
        <aside class="bcls-aside bcls-aside--tip">對於 Safari 和 iOS，您需要在添加提示點之前延遲，否則它們不會被添加。這是因為 Brightcove Player 在 Safari 瀏覽器和 iOS 上使用本機異步軌道。
      </li>
      <li>第22行：聽著<code translate="No">addtrack</code>事件。</li>
      <li>第23行：檢索與播放器關聯的所有文本軌道。</li>
      <li>第24行：設置<code translate="No">attLength</code>可變為文本軌道的數量。該值將在下一個代碼段的循環中使用。</li>
      <li>第25-30行：循環遍歷每個文本軌道，檢查是否存在<code translate="No">label</code>等於正確的值。找到後，將當前文本軌道分配給一個變量，然後退出循環。</li>
    </ul>
    <aside class="bcls-aside bcls-aside--tip">注意：在接下來的學習示例代碼之外，很可能會在包含關鍵提示點信息的某些數據結構上循環創建提示點。
    <pre class="line-numbers" data-start="1">
<code class="language-html" translate="No">&lt;video-js id="myPlayerID"
  data-video-id="4607746980001"
  data-account="1507807800001"
  data-player="default"
  data-embed="default"
  class="video-js"
  width="640" height="360"
  controls&gt;&lt;/video-js&gt;

&lt;script src="https://players.brightcove.net/1507807800001/default_default/index.min.js"&gt;&lt;/script&gt;

&lt;p id="insertionPoint"&gt;&lt;/p&gt;

&lt;script type="text/javascript"&gt;
  videojs.getPlayer("myPlayerID").ready(function () {
    var myPlayer = this,
      textTrack = [],
      allTextTacks,
      attLength,
      tt;
    myPlayer.one("loadedmetadata", function () {
      myPlayer.textTracks().addEventListener('addtrack', function () {
        allTextTacks = myPlayer.textTracks();
        attLength = allTextTacks.length;
        for (var i = 0; i &lt; attLength; i++) {
          if (allTextTacks[i].label === 'Timed Cue Point') {
            tt = allTextTacks[i];
            break;
          }
        }
        tt.oncuechange = function () {
          if (tt.activeCues[0] !== undefined) {
            var dynamicHTML = "id: " + tt.activeCues[0].id + ", ";
            dynamicHTML += "text: &lt;strong&gt;" + tt.activeCues[0].text + "&lt;/strong&gt;, ";
            dynamicHTML += "startTime: &lt;strong&gt;" + tt.activeCues[0].startTime + "&lt;/strong&gt;,  ";
            dynamicHTML += "endTime: &lt;strong&gt;" + tt.activeCues[0].endTime + "&lt;/strong&gt;";
            document.getElementById("insertionPoint").innerHTML += dynamicHTML + "&lt;br/&gt;&lt;br/&gt;";
          } else {
            document.getElementById("insertionPoint").innerHTML += "Cue point duration over" + "&lt;br/&gt;&lt;br/&gt;";
          }
        }; //end oncuechange
      }); // end playing
      textTrack = myPlayer.addRemoteTextTrack({kind: 'metadata', label: 'Timed Cue Point', mode: 'hidden'}, false);
      textTrack.track.mode = 'hidden';
      setTimeout(function(){
        textTrack.track.addCue(new window.VTTCue(2, 5, 'cue point 1 text'));
        textTrack.track.addCue(new window.VTTCue(10, 15, 'cue point 2 text'));
      }, 10);
    }); //end on loadedmetadata
  }); //end ready
&lt;/script&gt;</code></pre>
    <p>該代碼生成輸出，如以下屏幕截圖所示。注意<strong>ID</strong>使用時，不會為這些值提供值<code translate="No">VTTCue()</code>構造方法。</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="dynamic cue points" src="/assets/images/general/cue-points-dynamic.png" /></figure>
  </section>
  <section class="bcls-section">
    <h2 id="ID3_and_media_cue_points">ID3和媒體提示點</h2>
    <p>如果您有與媒體關聯的ID3提示點或媒體提示點，則可以使用<code translate="No">id3CuePointsTrack()</code>和<code translate="No">mediaCuePointsTrack()</code>方法。例如，要偵聽提示點更改，可以使用以下命令：</p>
    <pre class="line-numbers">
<code class="language-javascript" translate="No">videojs.getPlayer('myPlayerID').ready(function () {
  var myPlayer = this;
  myPlayer.one("canplay", function () {
    <span class="bcls-highlight">myPlayer.id3CuePointsTrack().on('cuechange', function () {
      // process cue point here
    });</span>
  });
});</code></pre>
    <h3>ID3詳細信息</h3>
    <p>以下內容提供了有關使用ID3提示點的更多信息：</p>
    <ul>
      <li>ID3標籤可用於將定時的元數據插入流中。</li>
      <li>每個段可以有多個ID3幀。</li>
      <li>Brightcove Player使用前面提到的方法解析ID3提示點並將其顯示為文本軌道<code translate="No">id3CuePointsTrack()</code>方法。</li>
      <li>最好的做法是等待<code translate="No">canplay</code>事件，或者在嘗試訪問該軌道時可能無法檢索該軌道。</li>
      <li>每個標籤支持多幀。</li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Known_issues">已知的問題</h2>
    <ul>
      <li>在Safari上，如果結束時間等於開始時間，則提示點不會觸發。因此，如果Safari兼容性是一個問題，提示點需要的持續時間必須大於零。</li>
    </ul>
  </section>
</article>
<script src="https://players.brightcove.net/1752604059001/VkIrj2aFx_default/index.min.js"></script><script src="https://players.brightcove.net/3676484087001/4f14e962-a11f-441f-8c00-0c89b8edb0a6_default/index.min.js"></script><script>
  videojs.getPlayer('myPlayerID').ready(function() { var player = this; player.one("loadedmetadata",function(){ var tt = player.textTracks()[0]; tt.oncuechange = function( ) { if(tt.activeCues[0] !== undefined){ var dynamicHTML = "id: <strong> " + tt.activeCues[0].id + ", "; dynamicHTML += "text: <strong> " + tt.activeCues[0].text + ", "; dynamicHTML += "startTime: <strong> " + tt.activeCues[0].startTime + ", "; dynamicHTML += "endTime: <strong> " + tt.activeCues[0].endTime + ""; document.getElementById("insertionPoint").innerHTML += dynamicHTML + "<br/>"; } } //player.play(); player.muted(true); }); });
  </script><script>
  videojs.getPlayer('myPlayerID2').ready(function() { var myPlayer = this; myPlayer.one("loadedmetadata",function(){ var trackIndex = myPlayer.textTracks().length -1; var tt = myPlayer. textTracks()[trackIndex]; tt.oncuechange = function() { if(tt.activeCues[0] !== undefined){ console.log('tt.activeCues[0]',tt.activeCues[0]); var dynamicHTML = "id: <strong> " + tt.activeCues[0].id + ", "; dynamicHTML += "text: <strong> " + tt.activeCues[0].text + ", "; dynamicHTML += "startTime: <strong> " + tt.activeCues[0].startTime + ", "; dynamicHTML += "endTime: <strong> " + tt.activeCues[0].endTime + ""; document.getElementById("insertionPoint2").innerHTML += dynamicHTML + "<br/><br/>"; jsonData = JSON.parse(tt.activeCues[0].text); document.getElementById("insertionPoint2").innerHTML += jsonData.title + ": " + jsonData.description + "<br/><br/>"; } else { document.getElementById("insertionPoint2").innerHTML += "<strong>Cue point duration over" + "<br/><br/>"; } } //end oncuechange //myPlayer.play(); myPlayer.muted(true); }); //end loadedmetadata }); //end ready
  </script><script>
  var myPlayer3, textTrack; videojs.getPlayer('myPlayerID3').ready(function() { var myPlayer3 = this; myPlayer3.src({ "type": "video/mp4", "src": "//solutions.brightcove.com/bcls/assets/videos/Water-In-Motion.mp4" } ); textTrack = myPlayer3.addTextTrack('metadata', 'Timed Cue Point'); textTrack.addCue(new window.VTTCue(2,4,'提示點1文本')); textTrack.addCue(new window.VTTCue(6,8,'提示點2文本')); textTrack.addCue(new window.VTTCue(10,11,'提示點 3 文本')); textTrack.addCue(new window.VTTCue(15,20,'cue point 4 text - LAST CUEPOINT')); var tt = myPlayer3.textTracks()[0]; tt.oncuechange = function() { if(tt.activeCues[0] !== undefined){ //var dynamicHTML = "id: " + tt.activeCues[0].id + ", "; var dynamicHTML = "文本：<strong> " + tt.activeCues[0].text + ", "; dynamicHTML += "startTime: <strong> " + tt.activeCues[0].startTime + ", "; dynamicHTML += "endTime: <strong> " + tt.activeCues[0].endTime + ""; document.getElementById("insertionPoint3").innerHTML += dynamicHTML + "<br/>"; } else { document.getElementById("insertionPoint3").innerHTML += "Cue point duration over" + "<br/><br/>"; } } //end oncuechange }); //end ready
  </script>