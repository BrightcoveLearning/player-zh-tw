<video id="myPlayerID"
data-video-id="6010362248001"
data-account="1752604059001"
data-player="default"
data-embed="default"
data-application-id
class="video-js"
controls></video>
<script src="//players.brightcove.net/1752604059001/default_default/index.min.js"></script>

<script>
  videojs.getPlayer("myPlayerID").ready(function() { // Create variables and new div, anchor and image for download icon var myPlayer = this, videoName, totalRenditions, mp4Ara = [], highestQuality, spacer, newElement = document.createElement("div"), newImage = document.createElement("img"); myPlayer.on("loadstart", function() { //Reinitialize array of MP4 renditions in case used with playlist //This prevents the array having a cumulative list for all videos in playlist mp4Ara = []; // +++ Get video name and the MP4 renditions +++ videoName = myPlayer.mediainfo["name"]; videoName = removeSpaces(videoName); rendtionsAra = myPlayer.mediainfo.sources; console.table(rendtionsAra) totalRenditions = rendtionsAra.length; // +++ Loop over videos and extract only MP4 versions +++ for (var i = 0; i &lt; totalRenditions; i++) { if ( rendtionsAra[i].container === "MP4" &amp;&amp; rendtionsAra[i].hasOwnProperty("src") ) { mp4Ara.push(rendtionsAra[i]); } } // +++ 按大小從高到低對再現進行排序+++ mp4Ara.sort(function(a, b) { return b.size - a.size; } ); console.table(mp4Ara) // +++ 提取最高版本 +++highestQuality = mp4Ara[0].src; // +++ 構建下載圖像元素 +++ newElement.id = "downloadImage"; newElement.className = "vjs-control downloadStyle"; newImage.setAttribute( "src", "https://solutions.brightcove.com/bcls/brightcove-player/download-video/file-download.png" ); newImage.style["cursor"] = "pointer"; // +++ 在圖像點擊時調用下載函數 +++ newImage.onclick = function() { // The download function forces download by the browsers // NOT opening the video in a new window/tab var x = new XMLHttpRequest(); x.open("GET", highestQuality, true); x.responseType = "blob"; x.onload = function(e) { download(x.response, videoName, "video/mp4"); } ; x.send(); // }; newElement.appendChild(newImage); // +++ 放置下載圖像 +++ // 獲取間隔元素的句柄 interval = myPlayer.controlBar.customControlSpacer.el(); // 設置spacer的內容為右對齊 separator.setAttribute("style", "justify-content: flex-end;"); // 將新元素放入間隔塊中 separator.appendChild(newElement); }); }); /* * 從字符串中刪除空格 * @param {String}要處理的字符串字符串 * @return {String}修剪後的字符串 */ 函數 removeSpaces(str) { str = str.replace(/\s/g, ""); return str; } //download.js v4.2, by dandavis; 2008-2016 年。 [CCBY2] 測試/使用見 http://danml.com/download.html // v1 登陸了 FF+Chrome 兼容方式將字符串下載到本地未命名文件，升級為使用隱藏框架和可選的 mime // v2 通過 a[download]、msSaveBlob、IE (10+) 支持和 window.URL 支持比 dataURLs 更大+更快的保存添加了命名文件 // v3 添加了 dataURL 和 Blob 輸入、綁定切換參數和舊的 dataURL 回退是通過強制下載 mime 和 base64 支持進行了改進。3.1 改進了野生動物園處理。//v4 增加了 AMD/UMD，共同 JS 和普通瀏覽器支持//v4.1 通過單個 URL 參數（僅限同一域/CORS）添加了 URL 下載功能//v4.2 添加語義變量名稱，長（超過 2MB）的數據 URL 支持，並隱藏默認臨時錨點//https://github.com/rndme/download（函數（根，工廠）{ if (typeof define === "function" &amp;&amp; define.amd) { // AMD. Register as an anonymous module. define([], factory); }否則，如果（導出類型 ==「對象」）{ // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(); }其他{ // Browser globals (root is window) root.download = factory(); } }）（這，函數（）{ return function download(data, strFileName, strMimeType) { var self = window, // this script is only for browsers anyway... defaultMime = "application/octet-stream", // this default mime also triggers iframe downloads mimeType = strMimeType || defaultMime, payload = data, url = !strFileName &amp;&amp; !strMimeType &amp;&amp; payload, anchor = document.createElement("a"), toString = function(a) { return String(a); }，myBlob = 自己。下載」, 斑點, 讀者; MyBlob = MyBlob.我的 BLOB. 綁定（自我）：Blob; 如果（字符串（這個）===「真」），{ //reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback payload = [payload, mimeType]; mimeType = payload[0]; payload = payload[1]; }如果（網址 &amp;&amp; url. 長度 &lt;  2048）{ // if no filename and no mime, assume a url was passed as the only argument fileName = url .split("/") .pop() .split("?")[0]; anchor.href = url; // assign href prop to temp anchor if (anchor.href.indexOf(url) !== -1) { // if the browser determines that it's a potentially valid url path: var ajax = new XMLHttpRequest(); ajax.open("GET", url, true); ajax.responseType = "blob"; ajax.onload = function(e) { download(e.target.response, fileName, defaultMime); } ; setTimeout（函數（）{ ajax.send(); }，0）;//允許使用返回設置自定義 ajax 頭：返回 ajax;}//結束，如果有效的網址？}//結束，如果網址？//如果（/^data\：[\ w+\-] +\/[\ w+\-] + [，;] /.test（有效載荷））{ if (payload.length &gt; 1024 * 1024 * 1.999 &amp;&amp; myBlob !== toString) { payload = dataUrlToBlob(payload); mimeType = payload.type || defaultMime; }否則{ return navigator.msSaveBlob // IE10 can't do a[download], only Blobs: ? navigator.msSaveBlob(dataUrlToBlob(payload), fileName) : saver(payload); // everyone else can save dataURLs un-processed } }//如果數據 URL 傳遞，則繼續下載數據 URL 立即下載？blob = 我的 Blob 的有效載荷實例？有效載荷：新的 MyBlob（[有效載荷]，{ type: mimeType }）; 函數數據數據庫（strURL）{ var parts = strUrl.split(/[:;,]/), type = parts[1], decoder = parts[2] == "base64" ? atob : decodeURIComponent, binData = decoder(parts.pop()), mx = binData.length, i = 0, uiArr = new Uint8Array(mx); for (i; i &lt; mx; ++i) uiArr[i] = binData.charCodeAt(i); return new myBlob([uiArr], { type: type }）;} 功能保護程序（網址，WinMode）{ if ("download" in anchor) { //html5 A[download] anchor.href = url; anchor.setAttribute("download", fileName); anchor.className = "download-js-link"; anchor.innerHTML = "downloading..."; anchor.style.display = "none"; document.body.appendChild(anchor); setTimeout(function() { anchor.click(); document.body.removeChild(anchor); if (winMode === true) { setTimeout(function() { self.URL.revokeObjectURL(anchor.href); }，250）;}}，66）; 返回 true;}//處理非 [下載] 野生動物園，我們可以：如果（/（版本）\/（\ d+）\。(\ d+) (?：\。（\ d+））？* 野生動物園\ //.test（導航器。用戶代理））{ url = url.replace(/^data:([\w\/\-\+]+)/, defaultMime); if (!window.open(url)) { // popup blocked, offer direct download: if ( confirm( "Displaying New Document\n\nUse Save As... to download, then click back to return to this page." ) ) { location.href = url; }返回真;} //做 iframe 數據網址下載（舊的 ch+FF）：變量 f = 文檔。創建元素（「iframe」）; 文檔。身體。附加子（f）; 如果（！WinMode）{ // force a mime that will download: url = "data:" + url.replace(/^data:([\w\/\-\+]+)/, defaultMime); }  F.src = 網址; 設置超時（函數（）{ document.body.removeChild(f); }，333）;}//結束保護程序，如果（導航器 .msSaveBlob），{ // IE10+ : (has Blob, but not a[download] or URL) return navigator.msSaveBlob(blob, fileName); }如果（自我 .URL）{ // simple fast and modern way using Blob and URL: saver(self.URL.createObjectURL(blob), true); }其他{ // handle non-Blob()+non-URL browsers: if (typeof blob === "string" || blob.constructor === toString) { try { return saver("data:" + mimeType + ";base64," + self.btoa(blob)); }捕獲（y）{ return saver("data:" + mimeType + "," + encodeURIComponent(blob)); } }//斑點但不支持 URL：閱讀器 = 新文件閱讀器（）{ saver(this.result); } ; 讀取器 .onload = 函數（e）; 讀者。讀取器。讀取器。

</script>